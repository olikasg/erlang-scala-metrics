<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>1996</year>
      <year>2007</year>
      <holder>Ericsson AB, All Rights Reserved</holder>
    </copyright>
    <legalnotice>
  The contents of this file are subject to the Erlang Public License,
  Version 1.1, (the "License"); you may not use this file except in
  compliance with the License. You should have received a copy of the
  Erlang Public License along with this software. If not, it can be
  retrieved online at http://www.erlang.org/.

  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
  the License for the specific language governing rights and limitations
  under the License.

  The Initial Developer of the Original Code is Ericsson AB.
    </legalnotice>

    <title>lists</title>
    <prepared>Robert Virding</prepared>
    <docno>1</docno>
    <date>96-09-28</date>
    <rev>A</rev>
  </header>
  <module>lists</module>
  <modulesummary>List Processing Functions</modulesummary>
  <description>
    <p>This module contains functions for list processing. The functions
      are organized in two groups: those in the first group perform a
      particular operation on one or more lists, whereas those in the
      second group are higher-order functions, using a fun as argument
      to perform an operation on one list.</p>
    <p>Unless otherwise stated, all functions assume that position
      numbering starts at 1. That is, the first element of a list is at
      position 1.</p>

    <p>Whenever an <marker
      id="ordering_function"></marker><em>ordering function</em>
      <c>F</c> is expected as argument, it is assumed that the
      following properties hold of <c>F</c> for all x, y and z:</p>
    <list type="bulleted">
      <item><p>if x <c>F</c> y and y <c>F</c> x then x = y (<c>F</c>
        is antisymmetric);</p>
      </item>
      <item><p>if x <c>F</c> y and and y <c>F</c> z then x <c>F</c> z
        (<c>F</c> is transitive);</p>
      </item>
      <item><p>x <c>F</c> y or y <c>F</c> x (<c>F</c> is total).</p>
      </item>
    </list>

  </description>
  <funcs>
    <func>
      <name>all(Pred, List) -> bool()</name>
      <fsummary>Return true if all elements in the list satisfy<c>Pred</c></fsummary>
      <type>
        <v>Pred = fun(Elem) -> bool()</v>
        <v>&nbsp;Elem = term()</v>
        <v>List = [term()]</v>
      </type>
      <desc>
        <p>Returns <c>true</c> if <c>Pred(Elem)</c> returns
          <c>true</c> for all elements <c>Elem</c> in <c>List</c>,
          otherwise <c>false</c>.</p>
      </desc>
    </func>
    <func>
      <name>any(Pred, List) -> bool()</name>
      <fsummary>Return true if any of the elements in the list satisfies<c>Pred</c></fsummary>
      <type>
        <v>Pred = fun(Elem) -> bool()</v>
        <v>&nbsp;Elem = term()</v>
        <v>List = [term()]</v>
      </type>
      <desc>
        <p>Returns <c>true</c> if <c>Pred(Elem)</c> returns
          <c>true</c> for at least one element <c>Elem</c> in
          <c>List</c>.</p>
      </desc>
    </func>
    <func>
      <name>append(ListOfLists) -> List1</name>
      <fsummary>Append a list of lists</fsummary>
      <type>
        <v>ListOfLists = [List]</v>
        <v>List = List1 = [term()]</v>
      </type>
      <desc>
        <p>Returns a list in which all the sub-lists of
          <c>ListOfLists</c> have been appended. For example:</p>
        <pre>
> <input>lists:append([[1, 2, 3], [a, b], [4, 5, 6]]).</input>
[1,2,3,a,b,4,5,6]</pre>
      </desc>
    </func>
    <func>
      <name>append(List1, List2) -> List3</name>
      <fsummary>Append two lists</fsummary>
      <type>
        <v>List1 = List2 = List3 = [term()]</v>
      </type>
      <desc>
        <p>Returns a new list <c>List3</c> which is made from
          the elements of <c>List1</c> followed by the elements of
          <c>List2</c>. For example:</p>
        <pre>
> <input>lists:append("abc", "def").</input>
"abcdef"</pre>
        <p><c>lists:append(A, B)</c> is equivalent to <c>A ++ B</c>.</p>
      </desc>
    </func>
    <func>
      <name>concat(Things) -> string()</name>
      <fsummary>Concatenate a list of atoms</fsummary>
      <type>
        <v>Things = [Thing]</v>
        <v>&nbsp;Thing = atom() | integer() | float() | string()</v>
      </type>
      <desc>
        <p>Concatenates the text representation of the elements
          of <c>Things</c>. The elements of <c>Things</c> can be atoms,
          integers, floats or strings.</p>
        <pre>
> <input>lists:concat([doc, '/', file, '.', 3]).</input>
"doc/file.3"</pre>
      </desc>
    </func>
    <func>
      <name>delete(Elem, List1) -> List2</name>
      <fsummary>Delete an element from a list</fsummary>
      <type>
        <v>Elem = term()</v>
        <v>List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p>Returns a copy of <c>List1</c> where the first element
          matching <c>Elem</c> is deleted, if there is such an
          element.</p>
      </desc>
    </func>
    <func>
      <name>dropwhile(Pred, List1) -> List2</name>
      <fsummary>Drop elements from a list while a predicate is true</fsummary>
      <type>
        <v>Pred = fun(Elem) -> bool()</v>
        <v>&nbsp;Elem = term()</v>
        <v>List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p>Drops elements <c>Elem</c> from <c>List1</c> while
          <c>Pred(Elem)</c> returns <c>true</c> and returns
          the remaining list.</p>
      </desc>
    </func>
    <func>
      <name>duplicate(N, Elem) -> List</name>
      <fsummary>Make N copies of element</fsummary>
      <type>
        <v>N = int()</v>
        <v>Elem = term()</v>
        <v>List = [term()]</v>
      </type>
      <desc>
        <p>Returns a list which contains N copies of the term
          <c>Elem</c>. For example:</p>
        <pre>
> <input>lists:duplicate(5, xx).</input>
[xx,xx,xx,xx,xx]</pre>
      </desc>
    </func>
    <func>
      <name>filter(Pred, List1) -> List2</name>
      <fsummary>Choose elements which satisfy a predicate</fsummary>
      <type>
        <v>Pred = fun(Elem) -> bool()</v>
        <v>&nbsp;Elem = term()</v>
        <v>List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p><c>List2</c> is a list of all elements <c>Elem</c> in
          <c>List1</c> for which <c>Pred(Elem)</c> returns
          <c>true</c>.</p>
      </desc>
    </func>
    <func>
      <name>flatlength(DeepList) -> int()</name>
      <fsummary>Length of flattened deep list</fsummary>
      <type>
        <v>DeepList = [term() | DeepList]</v>
      </type>
      <desc>
        <p>Equivalent to <c>length(flatten(DeepList))</c>, but more
          efficient.</p>
      </desc>
    </func>
    <func>
      <name>flatmap(Fun, List1) -> List2</name>
      <fsummary>Map and flatten in one pass</fsummary>
      <type>
        <v>Fun = fun(A) -> [B]</v>
        <v>List1 = [A]</v>
        <v>List2 = [B]</v>
        <v>&nbsp;A = B = term()</v>
      </type>
      <desc>
        <p>Takes a function from <c>A</c>s to lists of <c>B</c>s, and a
          list of <c>A</c>s (<c>List1</c>) and produces a list of
          <c>B</c>s by applying the function to every element in
          <c>List1</c> and appending the resulting lists.</p>
        <p>That is, <c>flatmap</c> behaves as if it had been defined as
          follows:</p>
        <code type="none">
flatmap(Fun, List1) ->
    append(map(Fun, List1))</code>
        <p>Example:</p>
        <pre>
> <input>lists:flatmap(fun(X)->[X,X] end, [a,b,c]).</input>
[a,a,b,b,c,c]</pre>
      </desc>
    </func>
    <func>
      <name>flatten(DeepList) -> List</name>
      <fsummary>Flatten a deep list</fsummary>
      <type>
        <v>DeepList = [term() | DeepList]</v>
        <v>List = [term()]</v>
      </type>
      <desc>
        <p>Returns a flattened version of <c>DeepList</c>.</p>
      </desc>
    </func>
    <func>
      <name>flatten(DeepList, Tail) -> List</name>
      <fsummary>Flatten a deep list</fsummary>
      <type>
        <v>DeepList = [term() | DeepList]</v>
        <v>Tail = List = [term()]</v>
      </type>
      <desc>
        <p>Returns a flattened version of <c>DeepList</c> with the tail
          <c>Tail</c> appended.</p>
      </desc>
    </func>
    <func>
      <name>foldl(Fun, Acc0, List) -> Acc1</name>
      <fsummary>Fold a function over a list</fsummary>
      <type>
        <v>Fun = fun(Elem, AccIn) -> AccOut</v>
        <v>&nbsp;Elem = term()</v>
        <v>Acc0 = Acc1 = AccIn = AccOut = term()</v>
        <v>List = [term()]</v>
      </type>
      <desc>
        <p>Calls <c>Fun(Elem, AccIn)</c> on successive elements <c>A</c>
          of <c>List</c>, starting with <c>AccIn == Acc0</c>.
          <c>Fun/2</c> must return a new accumulator which is passed to
          the next call. The function returns the final value of
          the accumulator. <c>Acc0</c> is returned if the list is empty.
          For example:</p>
        <pre>
> <input>lists:foldl(fun(X, Sum) -> X + Sum end, 0, [1,2,3,4,5]).</input>
15
> <input>lists:foldl(fun(X, Prod) -> X * Prod end, 1, [1,2,3,4,5]).</input>
120</pre>
      </desc>
    </func>
    <func>
      <name>foldr(Fun, Acc0, List) -> Acc1</name>
      <fsummary>Fold a function over a list</fsummary>
      <type>
        <v>Fun = fun(Elem, AccIn) -> AccOut</v>
        <v>&nbsp;Elem = term()</v>
        <v>Acc0 = Acc1 = AccIn = AccOut = term()</v>
        <v>List = [term()]</v>
      </type>
      <desc>
        <p>Like <c>foldl/3</c>, but the list is traversed from right to
          left. For example:</p>
        <pre>
> <input>P = fun(A, AccIn) -> io:format("~p ", [A]), AccIn end.</input>
#Fun&lt;erl_eval.12.2225172&gt;
> <input>lists:foldl(P, void, [1,2,3]).</input>
1 2 3 void
> <input>lists:foldr(P, void, [1,2,3]).</input>
3 2 1 void</pre>
        <p><c>foldl/3</c> is tail recursive and would usually be
          preferred to <c>foldr/3</c>.</p>
      </desc>
    </func>
    <func>
      <name>foreach(Fun, List) -> void()</name>
      <fsummary>Apply a function to each element of a list</fsummary>
      <type>
        <v>Fun = fun(Elem) -> void()</v>
        <v>&nbsp;Elem = term()</v>
        <v>List = [term()]</v>
      </type>
      <desc>
        <p>Calls <c>Fun(Elem)</c> for each element <c>Elem</c> in
          <c>List</c>. This function is used for its side effects and
          the evaluation order is defined to be the same as the order
          of the elements in the list.</p>
      </desc>
    </func>
    <func>
      <name>keydelete(Key, N, TupleList1) -> TupleList2</name>
      <fsummary>Delete an element from a list of tuples</fsummary>
      <type>
        <v>Key = term()</v>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList1 = TupleList2 = [Tuple]</v>
        <v>&nbsp;Tuple = tuple()</v>
      </type>
      <desc>
        <p>Returns a copy of <c>TupleList1</c> where the first
          occurrence of a tuple whose <c>N</c>th element compares equal to
          <c>Key</c> is deleted, if there is such a tuple.</p>
      </desc>
    </func>
    <func>
      <name>keymap(Fun, N, TupleList1) -> TupleList2</name>
      <fsummary>Map a function over a list of tuples</fsummary>
      <type>
        <v>Fun = fun(Term1) -> Term2</v>
        <v>&nbsp;Term1 = Term2 = term()</v>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList1 = TupleList2 = [tuple()]</v>
      </type>
      <desc>
        <p>Returns a list of tuples where, for each tuple in
          <c>TupleList1</c>, the <c>N</c>th element <c>Term1</c> of the tuple
          has been replaced with the result of calling
          <c>Fun(Term1)</c>.</p>
        <p>Examples:</p>
        <pre>
> <input>Fun = fun(Atom) -> atom_to_list(Atom) end.</input>
#Fun&lt;erl_eval.6.10732646&gt;
2> <input>lists:keymap(Fun, 2, [{name,jane,22},{name,lizzie,20},{name,lydia,15}]).</input>
[{name,"jane",22},{name,"lizzie",20},{name,"lydia",15}]</pre>
      </desc>
    </func>
    <func>
      <name>keymember(Key, N, TupleList) -> bool()</name>
      <fsummary>Test for membership of a list of tuples</fsummary>
      <type>
        <v>Key = term()</v>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList = [Tuple]</v>
        <v>&nbsp;Tuple = tuple()</v>
      </type>
      <desc>
        <p>Returns <c>true</c> if there is a tuple in <c>TupleList</c>
          whose <c>N</c>th element compares equal to <c>Key</c>, otherwise
          <c>false</c>.</p>
      </desc>
    </func>
    <func>
      <name>keymerge(N, TupleList1, TupleList2) -> TupleList3</name>
      <fsummary>Merge two key-sorted lists of tuples</fsummary>
      <type>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList1 = TupleList2 = TupleList3 = [Tuple]</v>
        <v>&nbsp;Tuple = tuple()</v>
      </type>
      <desc>
        <p>Returns the sorted list formed by merging <c>TupleList1</c>
          and <c>TupleList2</c>. The merge is performed on
          the <c>N</c>th element of each tuple. Both <c>TupleList1</c> and
          <c>TupleList2</c> must be key-sorted prior to evaluating this
          function. When two tuples compare equal, the tuple from
          <c>TupleList1</c> is picked before the tuple from
          <c>TupleList2</c>.</p>
      </desc>
    </func>
    <func>
      <name>keyreplace(Key, N, TupleList1, NewTuple) -> TupleList2</name>
      <fsummary>Replace an element in a list of tuples</fsummary>
      <type>
        <v>Key = term()</v>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList1 = TupleList2 = [Tuple]</v>
        <v>NewTuple = Tuple = tuple()</v>
      </type>
      <desc>
        <p>Returns a copy of <c>TupleList1</c> where the first
          occurrence of a <c>T</c> tuple whose <c>N</c>th element
          compares equal to <c>Key</c> is replaced with
          <c>NewTuple</c>, if there is such a tuple <c>T</c>.</p>
      </desc>
    </func>
    <func>
      <name>keysearch(Key, N, TupleList) -> {value, Tuple} | false</name>
      <fsummary>Search for an element in a list of tuples</fsummary>
      <type>
        <v>Key = term()</v>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList = [Tuple]</v>
        <v>Tuple = tuple()</v>
      </type>
      <desc>
        <p>Searches the list of tuples <c>TupleList</c> for a
          tuple whose <c>N</c>th element compares equal to <c>Key</c>.
          Returns <c>{value, Tuple}</c> if such a tuple is found,
          otherwise <c>false</c>.</p>
      </desc>
    </func>
    <func>
      <name>keysort(N, TupleList1) -> TupleList2</name>
      <fsummary>Sort a list of tuples</fsummary>
      <type>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList1 = TupleList2 = [Tuple]</v>
        <v>&nbsp;Tuple = tuple()</v>
      </type>
      <desc>
        <p>Returns a list containing the sorted elements of the list
          <c>TupleList1</c>. Sorting is performed on the <c>N</c>th
          element of the tuples.</p>
      </desc>
    </func>
    <func>
      <name>keystore(Key, N, TupleList1, NewTuple) -> TupleList2</name>
      <fsummary>Store an element in a list of tuples</fsummary>
      <type>
        <v>Key = term()</v>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList1 = TupleList2 = [Tuple]</v>
        <v>NewTuple = Tuple = tuple()</v>
      </type>
      <desc>
        <p>Returns a copy of <c>TupleList1</c> where the first
          occurrence of a tuple <c>T</c> whose <c>N</c>th element
          compares equal to <c>Key</c> is replaced with
          <c>NewTuple</c>, if there is such a tuple <c>T</c>. If there
          is no such tuple <c>T</c> a copy of <c>TupleList1</c> where
          [<c>NewTuple</c>] has been appended to the end is
          returned.</p>
      </desc>
    </func>
    <func>
      <name>keytake(Key, N, TupleList1) -> {value, Tuple, TupleList2} 
             | false</name>
      <fsummary>Extract an element from a list of tuples</fsummary>
      <type>
        <v>Key = term()</v>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList1 = TupleList2 = [Tuple]</v>
        <v>Tuple = tuple()</v>
      </type>
      <desc>
        <p>Searches the list of tuples <c>TupleList1</c> for a tuple
          whose <c>N</c>th element compares equal to <c>Key</c>.
          Returns <c>{value, Tuple, TupleList2}</c> if such a tuple is
          found, otherwise <c>false</c>. <c>TupleList2</c> is a copy
          of <c>TupleList1</c> where the first occurrence of
          <c>Tuple</c> has been removed.</p>
      </desc>
    </func>
    <func>
      <name>last(List) -> Last</name>
      <fsummary>Return last element in a list</fsummary>
      <type>
        <v>List = [term()], length(List) > 0</v>
        <v>Last = term()</v>
      </type>
      <desc>
        <p>Returns the last element in <c>List</c>.</p>
      </desc>
    </func>
    <func>
      <name>map(Fun, List1) -> List2</name>
      <fsummary>Map a function over a list</fsummary>
      <type>
        <v>Fun = fun(A) -> B</v>
        <v>List1 = [A]</v>
        <v>List2 = [B]</v>
        <v>&nbsp;A = B = term()</v>
      </type>
      <desc>
        <p>Takes a function from <c>A</c>s to <c>B</c>s, and a list of
          <c>A</c>s and produces a list of <c>B</c>s by applying
          the function to every element in the list. This function is
          used to obtain the return values. The evaluation order is
          implementation dependent.</p>
      </desc>
    </func>
    <func>
      <name>mapfoldl(Fun, Acc0, List1) -> {List2, Acc1}</name>
      <fsummary>Map and fold in one pass</fsummary>
      <type>
        <v>Fun = fun(A, AccIn) -> {B, AccOut}</v>
        <v>Acc0 = Acc1 = AccIn = AccOut = term()</v>
        <v>List1 = [A]</v>
        <v>List2 = [B]</v>
        <v>&nbsp;A = B = term()</v>
      </type>
      <desc>
        <p><c>mapfold</c> combines the operations of <c>map/2</c> and
          <c>foldl/3</c> into one pass. An example, summing
          the elements in a list and double them at the same time:</p>
        <pre>
> <input>lists:mapfoldl(fun(X, Sum) -> {2*X, X+Sum} end,</input>
<input>0, [1,2,3,4,5]).</input>
{[2,4,6,8,10],15}</pre>
      </desc>
    </func>
    <func>
      <name>mapfoldr(Fun, Acc0, List1) -> {List2, Acc1}</name>
      <fsummary>Map and fold in one pass</fsummary>
      <type>
        <v>Fun = fun(A, AccIn) -> {B, AccOut}</v>
        <v>Acc0 = Acc1 = AccIn = AccOut = term()</v>
        <v>List1 = [A]</v>
        <v>List2 = [B]</v>
        <v>&nbsp;A = B = term()</v>
      </type>
      <desc>
        <p><c>mapfold</c> combines the operations of <c>map/2</c> and
          <c>foldr/3</c> into one pass.</p>
      </desc>
    </func>
    <func>
      <name>max(List) -> Max</name>
      <fsummary>Return maximum element of a list</fsummary>
      <type>
        <v>List = [term()], length(List) > 0</v>
        <v>Max = term()</v>
      </type>
      <desc>
        <p>Returns the first element of <c>List</c> that compares
          greater than or equal to all other elements of
          <c>List</c>.</p>
      </desc>
    </func>
    <func>
      <name>member(Elem, List) -> bool()</name>
      <fsummary>Test for membership of a list</fsummary>
      <type>
        <v>Elem = term()</v>
        <v>List = [term()]</v>
      </type>
      <desc>
        <p>Returns <c>true</c> if <c>Elem</c> matches some element of
          <c>List</c>, otherwise <c>false</c>.</p>
      </desc>
    </func>
    <func>
      <name>merge(ListOfLists) -> List1</name>
      <fsummary>Merge a list of sorted lists</fsummary>
      <type>
        <v>ListOfLists = [List]</v>
        <v>List = List1 = [term()]</v>
      </type>
      <desc>
        <p>Returns the sorted list formed by merging all the sub-lists
          of <c>ListOfLists</c>. All sub-lists must be sorted prior to
          evaluating this function. When two elements compare equal,
          the element from the sub-list with the lowest position in
          <c>ListOfLists</c> is picked before the other element.</p>
      </desc>
    </func>
    <func>
      <name>merge(List1, List2) -> List3</name>
      <fsummary>Merge two sorted lists</fsummary>
      <type>
        <v>List1 = List2 = List3 = [term()]</v>
      </type>
      <desc>
        <p>Returns the sorted list formed by merging <c>List1</c> and
          <c>List2</c>. Both <c>List1</c> and <c>List2</c> must be
          sorted prior to evaluating this function. When two elements
          compare equal, the element from <c>List1</c> is picked
          before the element from <c>List2</c>.</p>
      </desc>
    </func>
    <func>
      <name>merge(Fun, List1, List2) -> List3</name>
      <fsummary>Merge two sorted list</fsummary>
      <type>
        <v>Fun = fun(A, B) -> bool()</v>
        <v>List1 = [A]</v>
        <v>List2 = [B]</v>
        <v>List3 = [A | B]</v>
        <v>&nbsp;A = B = term()</v>
      </type>
      <desc>
        <p>Returns the sorted list formed by merging <c>List1</c> and
          <c>List2</c>. Both <c>List1</c> and <c>List2</c> must be
          sorted according to the <seealso
          marker="#ordering_function">ordering function</seealso>
          <c>Fun</c> prior to evaluating this function. <c>Fun(A,
          B)</c> should return <c>true</c> if <c>A</c> comes before
          <c>B</c> in the ordering, <c>false</c> otherwise. When two
          elements compare equal, the element from <c>List1</c> is
          picked before the element from <c>List2</c>.</p>
      </desc>
    </func>
    <func>
      <name>merge3(List1, List2, List3) -> List4</name>
      <fsummary>Merge three sorted lists</fsummary>
      <type>
        <v>List1 = List2 = List3 = List4 = [term()]</v>
      </type>
      <desc>
        <p>Returns the sorted list formed by merging <c>List1</c>,
          <c>List2</c> and <c>List3</c>. All of <c>List1</c>,
          <c>List2</c> and <c>List3</c> must be sorted prior to
          evaluating this function. When two elements compare equal,
          the element from <c>List1</c>, if there is such an element,
          is picked before the other element, otherwise the element
          from <c>List2</c> is picked before the element from
          <c>List3</c>.</p>
      </desc>
    </func>
    <func>
      <name>min(List) -> Min</name>
      <fsummary>Return minimum element of a list</fsummary>
      <type>
        <v>List = [term()], length(List) > 0</v>
        <v>Min = term()</v>
      </type>
      <desc>
        <p>Returns the first element of <c>List</c> that compares
          less than or equal to all other elements of
          <c>List</c>.</p>
      </desc>
    </func>
    <func>
      <name>nth(N, List) -> Elem</name>
      <fsummary>Return the Nth element of a list</fsummary>
      <type>
        <v>N = 1..length(List)</v>
        <v>List = [term()]</v>
        <v>Elem = term()</v>
      </type>
      <desc>
        <p>Returns the <c>N</c>th element of <c>List</c>. For example:</p>
        <pre>
> <input>lists:nth(3, [a, b, c, d, e]).</input>
c</pre>
      </desc>
    </func>
    <func>
      <name>nthtail(N, List1) -> Tail</name>
      <fsummary>Return the Nth tail of a list</fsummary>
      <type>
        <v>N = 0..length(List1)</v>
        <v>List1 = Tail = [term()]</v>
      </type>
      <desc>
        <p>Returns the <c>N</c>th tail of <c>List</c>, that is, the sublist of
          <c>List</c> starting at <c>N+1</c> and continuing up to
          the end of the list. For example:</p>
        <pre>
> <input>lists:nthtail(3, [a, b, c, d, e]).</input>
[d,e]
> <input>tl(tl(tl([a, b, c, d, e]))).</input>
[d,e]
> <input>lists:nthtail(0, [a, b, c, d, e]).</input>
[a,b,c,d,e]
> <input>lists:nthtail(5, [a, b, c, d, e]).</input>
[]</pre>
      </desc>
    </func>
    <func>
      <name>partition(Pred, List) -> {Satisfying, NonSatisfying}</name>
      <fsummary>Partition a list into two lists based on a predicate</fsummary>
      <type>
        <v>Pred = fun(Elem) -> bool()</v>
        <v>&nbsp;Elem = term()</v>
        <v>List = Satisfying = NonSatisfying = [term()]</v>
      </type>
      <desc>
        <p>Partitions <c>List</c> into two lists, where the first list
          contains all elements for which <c>Pred(Elem)</c> returns
          <c>true</c>, and the second list contains all elements for
          which <c>Pred(Elem)</c> returns <c>false</c>.</p>
        <p>Examples:</p>
        <pre>
> <input>lists:partition(fun(A) -> A rem 2 == 1 end, [1,2,3,4,5,6,7]).</input>
{[1,3,5,7],[2,4,6]}
> <input>lists:partition(fun(A) -> is_atom(A) end, [a,b,1,c,d,2,3,4,e]).</input>
{[a,b,c,d,e],[1,2,3,4]}</pre>
        <p>See also <c>splitwith/2</c> for a different way to partition
          a list.</p>
      </desc>
    </func>
    <func>
      <name>prefix(List1, List2) -> bool()</name>
      <fsummary>Test for list prefix</fsummary>
      <type>
        <v>List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p>Returns <c>true</c> if <c>List1</c> is a prefix of
          <c>List2</c>, otherwise <c>false</c>.</p>
      </desc>
    </func>
    <func>
      <name>reverse(List1) -> List2</name>
      <fsummary>Reverse a list</fsummary>
      <type>
        <v>List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p>Returns a list with the top level elements in <c>List1</c>
          in reverse order.</p>
      </desc>
    </func>
    <func>
      <name>reverse(List1, Tail) -> List2</name>
      <fsummary>Reverse a list appending a tail</fsummary>
      <type>
        <v>List1 = Tail = List2 = [term()]</v>
      </type>
      <desc>
        <p>Returns a list with the top level elements in <c>List1</c>
          in reverse order, with the tail <c>Tail</c> appended. For
          example:</p>
        <pre>
> <input>lists:reverse([1, 2, 3, 4], [a, b, c]).</input>
[4,3,2,1,a,b,c]</pre>
      </desc>
    </func>
    <func>
      <name>seq(From, To) -> Seq</name>
      <name>seq(From, To, Incr) -> Seq</name>
      <fsummary>Generate a sequence of integers</fsummary>
      <type>
        <v>From = To = Incr = int()</v>
        <v>Seq = [int()]</v>
      </type>
      <desc>
        <p>Returns a sequence of integers which starts with <c>From</c>
          and contains the successive results of adding <c>Incr</c> to
          the previous element, until <c>To</c> has been reached or
          passed (in the latter case, <c>To</c> is not an element of
          the sequence). <c>Incr</c> defaults to 1.</p>
        <p>Failure: If <c><![CDATA[To<From]]></c> and <c>Incr</c> is positive, or
          if <c>To>From</c> and <c>Incr</c> is negative, or if
          <c>Incr==0</c> and <c>From/=To</c>.</p>
        <p>Examples:</p>
        <pre>
> <input>lists:seq(1, 10).</input>
[1,2,3,4,5,6,7,8,9,10]
> <input>lists:seq(1, 20, 3).</input>
[1,4,7,10,13,16,19]
> <input>lists:seq(1, 1, 0).</input>
[1]</pre>
      </desc>
    </func>
    <func>
      <name>sort(List1) -> List2</name>
      <fsummary>Sort a list</fsummary>
      <type>
        <v>List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p>Returns a list containing the sorted elements of
          <c>List1</c>.</p>
      </desc>
    </func>
    <func>
      <name>sort(Fun, List1) -> List2</name>
      <fsummary>Sort a list</fsummary>
      <type>
        <v>Fun = fun(Elem1, Elem2) -> bool()</v>
        <v>&nbsp;Elem1 = Elem2 = term()</v>
        <v>List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p>Returns a list containing the sorted elements of
          <c>List1</c>, according to the <seealso
          marker="#ordering_function">ordering function</seealso>
          <c>Fun</c>. <c>Fun(A, B)</c> should return <c>true</c> if
          <c>A</c> comes before <c>B</c> in the ordering, <c>false</c>
          otherwise.</p>
      </desc>
    </func>
    <func>
      <name>split(N, List1) -> {List2, List3}</name>
      <fsummary>Split a list into two lists</fsummary>
      <type>
        <v>N = 0..length(List1)</v>
        <v>List1 = List2 = List3 = [term()]</v>
      </type>
      <desc>
        <p>Splits <c>List1</c> into <c>List2</c> and <c>List3</c>.
          <c>List2</c> contains the first <c>N</c> elements and
          <c>List3</c> the rest of the elements (the <c>N</c>th tail).</p>
      </desc>
    </func>
    <func>
      <name>splitwith(Pred, List) -> {List1, List2}</name>
      <fsummary>Split a list into two lists based on a predicate</fsummary>
      <type>
        <v>Pred = fun(Elem) -> bool()</v>
        <v>&nbsp;Elem = term()</v>
        <v>List = List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p>Partitions <c>List</c> into two lists according to
          <c>Pred</c>. <c>splitwith/2</c> behaves as if it is defined
          as follows:</p>
        <code type="none">
splitwith(Pred, List) -> 
    {takewhile(Pred, List), dropwhile(Pred, List)}.</code>
        <p>Examples:</p>
        <pre>
> <input>lists:splitwith(fun(A) -> A rem 2 == 1 end, [1,2,3,4,5,6,7]).</input>
{[1],[2,3,4,5,6,7]}
> <input>lists:splitwith(fun(A) -> is_atom(A) end, [a,b,1,c,d,2,3,4,e]).</input>
{[a,b],[1,c,d,2,3,4,e]}</pre>
        <p>See also <c>partition/2</c> for a different way to partition
          a list.</p>
      </desc>
    </func>
    <func>
      <name>sublist(List1, Len) -> List2</name>
      <fsummary>Return a sub-list of a certain length, starting at the first position</fsummary>
      <type>
        <v>List1 = List2 = [term()]</v>
        <v>Len = int()</v>
      </type>
      <desc>
        <p>Returns the sub-list of <c>List1</c> starting at position 1
          and with (max) <c>Len</c> elements. It is not an error for
          <c>Len</c> to exceed the length of the list -- in that case
          the whole list is returned.</p>
      </desc>
    </func>
    <func>
      <name>sublist(List1, Start, Len) -> List2</name>
      <fsummary>Return a sub-list starting at a given position and with a given number of elements</fsummary>
      <type>
        <v>List1 = List2 = [term()]</v>
        <v>Start = 1..(length(List1)+1)</v>
        <v>Len = int()</v>
      </type>
      <desc>
        <p>Returns the sub-list of <c>List1</c> starting at <c>Start</c>
          and with (max) <c>Len</c> elements. It is not an error for
          <c>Start+Len</c> to exceed the length of the list.</p>
        <pre>
> <input>lists:sublist([1,2,3,4], 2, 2).</input>
[2,3]
> <input>lists:sublist([1,2,3,4], 2, 5).</input>
[2,3,4]
> <input>lists:sublist([1,2,3,4], 5, 2).</input>
[]</pre>
      </desc>
    </func>
    <func>
      <name>subtract(List1, List2) -> List3</name>
      <fsummary>Subtract the element in one list from another list</fsummary>
      <type>
        <v>List1 = List2 = List3 = [term()]</v>
      </type>
      <desc>
        <p>Returns a new list <c>List3</c> which is a copy of
          <c>List1</c>, subjected to the following procedure: for each
          element in <c>List2</c>, its first occurrence in <c>List1</c>
          is deleted. For example:</p>
        <pre>
> <input>lists:subtract("123212", "212").</input>
"312".</pre>
        <p><c>lists:subtract(A,B)</c> is equivalent to <c>A -- B</c>.</p>
      </desc>
    </func>
    <func>
      <name>suffix(List1, List2) -> bool()</name>
      <fsummary>Test for list suffix</fsummary>
      <desc>
        <p>Returns <c>true</c> if <c>List1</c> is a suffix of
          <c>List2</c>, otherwise <c>false</c>.</p>
      </desc>
    </func>
    <func>
      <name>sum(List) -> number()</name>
      <fsummary>Return sum of elements in a list</fsummary>
      <type>
        <v>List = [number()]</v>
      </type>
      <desc>
        <p>Returns the sum of the elements in <c>List</c>.</p>
      </desc>
    </func>
    <func>
      <name>takewhile(Pred, List1) -> List2</name>
      <fsummary>Take elements from a list while a predicate is true</fsummary>
      <type>
        <v>Pred = fun(Elem) -> bool()</v>
        <v>&nbsp;Elem = term()</v>
        <v>List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p>Takes elements <c>Elem</c> from <c>List1</c> while
          <c>Pred(Elem)</c> returns <c>true</c>, that is,
          the function returns the longest prefix of the list for which
          all elements satisfy the predicate.</p>
      </desc>
    </func>
    <func>
      <name>ukeymerge(N, TupleList1, TupleList2) -> TupleList3</name>
      <fsummary>Merge two key-sorted lists of tuples, removing duplicates</fsummary>
      <type>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList1 = TupleList2 = TupleList3 = [Tuple]</v>
        <v>&nbsp;Tuple = tuple()</v>
      </type>
      <desc>
        <p>Returns the sorted list formed by merging <c>TupleList1</c>
          and <c>TupleList2</c>. The merge is performed on the
          <c>N</c>th element of each tuple. Both <c>TupleList1</c> and
          <c>TupleList2</c> must be key-sorted without duplicates
          prior to evaluating this function. When two tuples compare
          equal, the tuple from <c>TupleList1</c> is picked and the
          one from <c>TupleList2</c> deleted.</p>
      </desc>
    </func>
    <func>
      <name>ukeysort(N, TupleList1) -> TupleList2</name>
      <fsummary>Sort a list of tuples, removing duplicates</fsummary>
      <type>
        <v>N = 1..tuple_size(Tuple)</v>
        <v>TupleList1 = TupleList2 = [Tuple]</v>
        <v>&nbsp;Tuple = tuple()</v>
      </type>
      <desc>
        <p>Returns a list containing the sorted elements of the list
          <c>TupleList1</c> where all but the first tuple of the
          tuples comparing equal have been deleted. Sorting is
          performed on the <c>N</c>th element of the tuples.</p>
      </desc>
    </func>
    <func>
      <name>umerge(ListOfLists) -> List1</name>
      <fsummary>Merge a list of sorted lists, removing duplicates</fsummary>
      <type>
        <v>ListOfLists = [List]</v>
        <v>List = List1 = [term()]</v>
      </type>
      <desc>
        <p>Returns the sorted list formed by merging all the sub-lists
          of <c>ListOfLists</c>. All sub-lists must be sorted and
          contain no duplicates prior to evaluating this function.
          When two elements compare equal, the element from the
          sub-list with the lowest position in <c>ListOfLists</c> is
          picked and the other one deleted.</p>
      </desc>
    </func>
    <func>
      <name>umerge(List1, List2) -> List3</name>
      <fsummary>Merge two sorted lists, removing duplicates</fsummary>
      <type>
        <v>List1 = List2 = List3 = [term()]</v>
      </type>
      <desc>
        <p>Returns the sorted list formed by merging <c>List1</c> and
          <c>List2</c>. Both <c>List1</c> and <c>List2</c> must be
          sorted and contain no duplicates prior to evaluating this
          function. When two elements compare equal, the element from
          <c>List1</c> is picked and the one from <c>List2</c>
          deleted.</p>
      </desc>
    </func>
    <func>
      <name>umerge(Fun, List1, List2) -> List3</name>
      <fsummary>Merge two sorted lists, removing duplicates</fsummary>
      <type>
        <v>Fun = fun(A, B) -> bool()</v>
        <v>List1 = [A]</v>
        <v>List2 = [B]</v>
        <v>List3 = [A | B]</v>
        <v>&nbsp;A = B = term()</v>
      </type>
      <desc>
        <p>Returns the sorted list formed by merging <c>List1</c> and
          <c>List2</c>. Both <c>List1</c> and <c>List2</c> must be
          sorted according to the <seealso
          marker="#ordering_function">ordering function</seealso>
          <c>Fun</c> and contain no duplicates prior to evaluating
          this function. <c>Fun(A, B)</c> should return <c>true</c> if
          <c>A</c> comes before <c>B</c> in the ordering, <c>false</c>
          otherwise. When two elements compare equal, the element from
          <c>List1</c> is picked and the one from <c>List2</c>
          deleted.</p>
      </desc>
    </func>
    <func>
      <name>umerge3(List1, List2, List3) -> List4</name>
      <fsummary>Merge three sorted lists, removing duplicates</fsummary>
      <type>
        <v>List1 = List2 = List3 = List4 = [term()]</v>
      </type>
      <desc>
        <p>Returns the sorted list formed by merging <c>List1</c>,
          <c>List2</c> and <c>List3</c>. All of <c>List1</c>,
          <c>List2</c> and <c>List3</c> must be sorted and contain no
          duplicates prior to evaluating this function. When two
          elements compare equal, the element from <c>List1</c> is
          picked if there is such an element, otherwise the element
          from <c>List2</c> is picked, and the other one deleted.</p>
      </desc>
    </func>
    <func>
      <name>unzip(List1) -> {List2, List3}</name>
      <fsummary>Unzip a list of two-tuples into two lists</fsummary>
      <type>
        <v>List1 = [{X, Y}]</v>
        <v>List2 = [X]</v>
        <v>List3 = [Y]</v>
        <v>&nbsp;X = Y = term()</v>
      </type>
      <desc>
        <p>"Unzips" a list of two-tuples into two lists, where the first
          list contains the first element of each tuple, and the second
          list contains the second element of each tuple.</p>
      </desc>
    </func>
    <func>
      <name>unzip3(List1) -> {List2, List3, List4}</name>
      <fsummary>Unzip a list of three-tuples into three lists</fsummary>
      <type>
        <v>List1 = [{X, Y, Z}]</v>
        <v>List2 = [X]</v>
        <v>List3 = [Y]</v>
        <v>List4 = [Z]</v>
        <v>&nbsp;X = Y = Z = term()</v>
      </type>
      <desc>
        <p>"Unzips" a list of three-tuples into three lists, where
          the first list contains the first element of each tuple,
          the second list contains the second element of each tuple, and
          the third list contains the third element of each tuple.</p>
      </desc>
    </func>
    <func>
      <name>usort(List1) -> List2</name>
      <fsummary>Sort a list, removing duplicates</fsummary>
      <type>
        <v>List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p>Returns a list containing the sorted elements of
          <c>List1</c> where all but the first element of the elements
          comparing equal have been deleted.</p>
      </desc>
    </func>
    <func>
      <name>usort(Fun, List1) -> List2</name>
      <fsummary>Sort a list, removing duplicates</fsummary>
      <type>
        <v>Fun = fun(Elem1, Elem2) -> bool()</v>
        <v>&nbsp;Elem1 = Elem2 = term()</v>
        <v>List1 = List2 = [term()]</v>
      </type>
      <desc>
        <p>Returns a list which contains the sorted elements of
          <c>List1</c> where all but the first element of the elements
          comparing equal according to the <seealso
          marker="#ordering_function">ordering function</seealso>
          <c>Fun</c> have been deleted. <c>Fun(A, B)</c> should return
          <c>true</c> if <c>A</c> comes before <c>B</c> in the
          ordering, <c>false</c> otherwise.</p>
      </desc>
    </func>
    <func>
      <name>zip(List1, List2) -> List3</name>
      <fsummary>Zip two lists into a list of two-tuples</fsummary>
      <type>
        <v>List1 = [X]</v>
        <v>List2 = [Y]</v>
        <v>List3 = [{X, Y}]</v>
        <v>&nbsp;X = Y = term()</v>
      </type>
      <desc>
        <p>"Zips" two lists of equal length into one list of two-tuples,
          where the first element of each tuple is taken from the first
          list and the second element is taken from corresponding
          element in the second list.</p>
      </desc>
    </func>
    <func>
      <name>zip3(List1, List2, List3) -> List4</name>
      <fsummary>Zip three lists into a list of three-tuples</fsummary>
      <type>
        <v>List1 = [X]</v>
        <v>List2 = [Y]</v>
        <v>List3 = [Z]</v>
        <v>List3 = [{X, Y, Z}]</v>
        <v>&nbsp;X = Y = Z = term()</v>
      </type>
      <desc>
        <p>"Zips" three lists of equal length into one list of
          three-tuples, where the first element of each tuple is taken
          from the first list, the second element is taken from
          corresponding element in the second list, and the third
          element is taken from the corresponding element in the third
          list.</p>
      </desc>
    </func>
    <func>
      <name>zipwith(Combine, List1, List2) -> List3</name>
      <fsummary>Zip two lists into one list according to a fun</fsummary>
      <type>
        <v>Combine = fun(X, Y) -> T</v>
        <v>List1 = [X]</v>
        <v>List2 = [Y]</v>
        <v>List3 = [T]</v>
        <v>&nbsp;X = Y = T = term()</v>
      </type>
      <desc>
        <p>Combine the elements of two lists of equal length into one
          list. For each pair <c>X, Y</c> of list elements from the two
          lists, the element in the result list will be
          <c>Combine(X, Y)</c>.</p>
        <p><c>zipwith(fun(X, Y) -> {X,Y} end, List1, List2)</c> is
          equivalent to <c>zip(List1, List2)</c>.</p>
        <p>Example:</p>
        <pre>
> <input>lists:zipwith(fun(X, Y) -> X+Y end, [1,2,3], [4,5,6]).</input>
[5,7,9]</pre>
      </desc>
    </func>
    <func>
      <name>zipwith3(Combine, List1, List2, List3) -> List4</name>
      <fsummary>Zip three lists into one list according to a fun</fsummary>
      <type>
        <v>Combine = fun(X, Y, Z) -> T</v>
        <v>List1 = [X]</v>
        <v>List2 = [Y]</v>
        <v>List3 = [Z]</v>
        <v>List4 = [T]</v>
        <v>&nbsp;X = Y = Z = T = term()</v>
      </type>
      <desc>
        <p>Combine the elements of three lists of equal length into one
          list. For each triple <c>X, Y, Z</c> of list elements from
          the three lists, the element in the result list will be
          <c>Combine(X, Y, Z)</c>.</p>
        <p><c>zipwith3(fun(X, Y, Z) -> {X,Y,Z} end, List1, List2, List3)</c> is equivalent to <c>zip3(List1, List2, List3)</c>.</p>
        <p>Examples:</p>
        <pre>
> <input>lists:zipwith3(fun(X, Y, Z) -> X+Y+Z end, [1,2,3], [4,5,6], [7,8,9]).</input>
[12,15,18]
> <input>lists:zipwith3(fun(X, Y, Z) -> [X,Y,Z] end, [a,b,c], [x,y,z], [1,2,3]).</input>
[[a,x,1],[b,y,2],[c,z,3]]</pre>
      </desc>
    </func>
  </funcs>
</erlref>

