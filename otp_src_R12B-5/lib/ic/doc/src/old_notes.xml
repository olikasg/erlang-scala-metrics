<?xml version="1.0" encoding="latin1" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>2003</year>
      <year>2008</year>
      <holder>Ericsson AB, All Rights Reserved</holder>
    </copyright>
    <legalnotice>
  The contents of this file are subject to the Erlang Public License,
  Version 1.1, (the "License"); you may not use this file except in
  compliance with the License. You should have received a copy of the
  Erlang Public License along with this software. If not, it can be
  retrieved online at http://www.erlang.org/.

  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
  the License for the specific language governing rights and limitations
  under the License.

  The Initial Developer of the Original Code is Ericsson AB.
    </legalnotice>

    <title>IDL Compiler Release Notes</title>
    <prepared></prepared>
    <docno></docno>
    <checked></checked>
    <date>2003-11-19</date>
    <rev>AB</rev>
  </header>

  <section>
    <title>IC 4.1.8</title>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>IDL-files containing <c>result</c> or <c>Result</c> as,
            for example, parameter name, caused an exit with reason
            <c>bad_match</c>.</p>
          <p>Own Id: OTP-4532</p>
        </item>
        <item>
          <p>Uninitialized variables were used in <c>ic_init_ref</c> for
            C backends. </p>
          <p>Own Id: OTP-4537            <br></br>

            Aux Id: seq7666, ETOtr17107</p>
        </item>
        <item>
          <p><c>CORBA_Environment_alloc()</c> left some fields
            uninitialized in the returned pointer to an
            <c>CORBA_Environment</c> for C backends.</p>
          <p>Own Id: OTP-4538</p>
        </item>
        <item>
          <p>The function <c>ic_compare_refs()</c> for C backends
            could find two unequal references to be equal.</p>
          <p>Own Id: OTP-4539</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.1.7</title>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>Operation names were always scoped in C server backend,
            irrespective of the setting of the option
            <c>scoped_op_calls</c>.</p>
          <p>Own Id: OTP-4521            <br></br>

            Aux Id: seq7643, ETOtr16925</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.1.6</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>For C backends generated code checks that the
            <c>_length</c> field of bounded sequences (i.e. specified
            as <c><![CDATA[sequence <TYPE, MAX>]]></c>) does not exceed the
            specified maximum length. If so, an exception is raised.</p>
          <p>Own Id: OTP-4471</p>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>The <c>_maximum</c> field was not set for sequence structs
            generated by the C backends.</p>
          <p>Own Id: OTP-4471            <br></br>

            Aux Id: seq7600, ETOtr16308</p>
        </item>
        <item>
          <p>There was a memory leak in C backends in case there was a
            decoding error in a sequence with elements of basic type.</p>
          <p>Own Id: OTP-4475</p>
        </item>
        <item>
          <p>For for C backends, IDL structs defined within an
            interface were not mapped into C structs in appropriate
            include files.</p>
          <p>Own Id: OTP-4481            <br></br>

            Aux Id: seq7617</p>
        </item>
        <item>
          <p>If the user, incorrectly, trap exit's but did not use the
            'handle_info' compile option it would cause the server to
            terminate. The same problem occurred if someone,
            illegally, sent a message to the server. It could also
            happen for illegal oneway operations.</p>
          <p>Own Id: OTP-4488</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.1.5</title>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>Invalid C code was generated for type short. </p>
          <p>Own Id: OTP-4450            <br></br>

            Aux Id: seq7582</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.1.4</title>
    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>Operation functions inherited by an interface were not
            placed in the map table in generated code for the C server
            backend.  As a result such functions were not found by the
            switch function of the interface.</p>
          <p>Own Id: OTP-4448            <br></br>

            Aux Id: seq7582</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.1.3.1</title>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A non-ANSI compliant construct in libic.a was changed.</p>
          <p>Own Id: -</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.1.3</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>For Erlang and C back-ends an IC version stamp has been
            added to generated source code. This stamp i preserved in
            compiled target code.</p>
        </item>
        <item>
          <p>For C backends an <c>assert()</c> expression has been
            added to generated code. That expression asserts that the
            result of a memory allocation size calculation is strictly
            positive. An error will result in a printout and an
            <c>abort()</c>. The assertion can be inhibited by defining
            the macro <c>NDEBUG</c> (according to ANSI C).</p>
          <p>If the assertion is inhibited, and a size calculation error
            is detected, an INTERNAL CORBA exception is set. </p>
        </item>
        <item>
          <p>An internal reorganization of C backend generator code has
            been done (addition of module <c>ic_cclient</c>).  Several
            changes has been done in generated C code:</p>
          <list type="bulleted">
            <item>
              <p>The typedef <c>___generic___</c> has been replaced by
                the typedef <c>___exec_function___</c>, which has been
                made more strict; for backward compatibility the
                <c>___genereric___</c> typedef is now an alias for
                <c>___exec_function___</c>.</p>
            </item>
            <item>
              <p>Function parameters that are arrays, has been changed
                to be pointers to array slices, which are equivalent
                according to ANSI C. </p>
            </item>
            <item>
              <p>The storage class specifier <c>extern</c> has been
                removed from function prototypes in header files.</p>
            </item>
            <item>
              <p>Redundant type casts have been removed from generated code.
                Also some local "generic" variables have been renamed.</p>
            </item>
          </list>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>Module info vsn replaced by app_vsn.</p>
          <p>Own Id: OTP-4341</p>
        </item>
        <item>
          <p>IC-4.1.2 disabled the definition of float constants
            beginning with a zero (e.g. <c>0.14</c>).</p>
          <p>Own Id: OTP-4367</p>
        </item>
        <item>
          <p>IC did not handle constant definitions correctly for
            char, string, wchar and wstring.</p>
          <p>Own Id: OTP-4067, OTP-3222</p>
        </item>
        <item>
          <p>IC did not recognize all reserved words defined in the
            OMG specification (2.3.1). The new keywords are <c>fixed, abstract, custom, factory, local, native, private, public, supports, truncatable, 'ValueBase'</c> and
            <c>valuetype</c>. But for now this is only active for the
            <c>erl_corba</c> backend and only incorrect usage of
            <c>fixed</c>, since this datatype is now supported,
            triggers an error for this backend.</p>
          <p>Own Id: OTP-4368</p>
        </item>
        <item>
          <p>It was not possible to use wchar or wstring inside a
            union body when using the Java backend.</p>
          <p>Own Id:
            OTP-4365</p>
        </item>
        <item>
          <p>The compile options <c>this</c> and <c>handle_info</c>
            did not behave as described in the documentation. The
            <c>timeout</c> now behaves as, for example,
            <c>handle_info</c>.</p>
          <p>Own Id: OTP-4386, OTP-3231</p>
        </item>
        <item>
          <p>If we typedef a sequence, which contains a struct or a union,
            the access function <c>id/0</c> returned an incorrect IFR Id
            if a prefix pragma was used.</p>
          <p>Own Id: OTP-4387</p>
        </item>
        <item>
          <p>If an IDL file contained a prefix pragma, incorrect
            IFR-id's was generated in the IFR-registration operation
            <c>oe_register</c> for aliases (typedef) and
            attributes.</p>
          <p>Own Id: OTP-4388, OTP-4392</p>
        </item>
        <item>
          <p>For C back-ends, when encodings/decodings failed, memory
            allocated for variable size parameter types was not freed.</p>
          <p>Own Id: OTP-4391
                        <br></br>
Aux Id: seq7438, ETOtr14009</p>
        </item>
        <item>
          <p>If an IDL file contained a multiple typedef 
            (e.g. typedef string str1, str2;), the <c>oe_unregister</c>
            operation failed to remove all data, in this case str2,
            from the IFR.</p>
          <p>Own Id: OTP-4393</p>
        </item>
        <item>
          <p>IC did not recognize octet-constants 
            (e.g. const octet octetmax = 255;).</p>
          <p>Own Id: OTP-4400</p>
        </item>
        <item>
          <p>Negative 'long long' constants was not accepted 
            (e.g. const long long MyConstant = -1;).</p>
          <p>Own Id: OTP-4401</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.1.2</title>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>Merging of map's (<em>___map___</em>) using the 
            <em>___merge___</em> function does not work.</p>
          <p>Own Id: OTP-4323</p>
        </item>
        <item>
          <p>Error in generated C decode/encode functions for union's with 
            discriminator where the union has no value for all discriminator
            values. E.g. a union with discriminator boolean where only the 
            discriminator value TRUE has a corresponding union value.
            Here is how such a thing would look in IDL:</p>
          <pre>
\011    union OptXList switch(boolean) {
\011       case TRUE: integer  val;
            };
          </pre>
          <p>Own Id: OTP-4322</p>
        </item>
        <item>
          <p>Scoped op calls ('{scoped_op_calls, true}') does not handle
            module/function names beginning with capital letter (e.g. 
            Megaco should be 'Megaco') for oneway operations (handle_cast).</p>
          <p>Own Id: OTP-4310</p>
        </item>
        <item>
          <p>A bug is fixed on C-IDL erlang binaries that caused 
            pointer error when residing inside sequences.</p>
          <p>Own Id: OTP-4303</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.1.1</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>A new option 'multiple_be' is added that allows multiple backend 
            generation for the same IDL file.</p>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A bug is fixed on IDL types that contain underscore '_'.</p>
          <p>Own Id: OTP-3710</p>
        </item>
        <item>
          <p>A bug is fixed on IDL structs that caused scope confusion 
            when types and fields of a struct had the same name.</p>
          <p>Own Id: OTP-2893</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.0.7</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>The Erlang binary special type is introduced, that 
            allows efficient transfer of binaries between Erlang and C. </p>
          <p>Own Id:OTP-4107</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.0.6</title>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A bug is fixed on noc backend which caused generation of errornous code.</p>
          <p>Own Id: OTP-3812</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.0.5</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>The pragma code option is extended to point
            specific functions on NOC backent, not only
            interfaces.</p>
          <p></p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.0.4</title>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A bug in pragma prefix when including IDL files is fixed. 
            This caused problems for Erlang-corba IFR registrations.</p>
          <p>Own Id: OTP-3620</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.0.3</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>Limited support on multiple file module definitions.</p>
          <p>The current version supports multiple file module definitions all 
            backends except the c oriented backends.</p>
          <p>Own Id: OTP-3550</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.0.2</title>
    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A bug is fixed on Erlang backends.</p>
          <p>The (recently) introduced generation of files 
            describing sequence and array files were even
            true for included interfaces. In the case of 
            some Erlang backends this were unnecessary.</p>
          <p>Own Id: OTP-3485</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.0.1</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>New functionality added on Java and Erl_genserv backends.</p>
          <p></p>
          <list type="bulleted">
            <item>
              <p>On the Java client stub :</p>
              <p></p>
              <list type="bulleted">
                <item>
                  <p>The Java client have now one more constructor function,
                    that allows to continue with an already started connection.</p>
                </item>
                <item>
                  <p><c>void __stop()</c>  which sends a stop cast call to the server.
                    While this causes the Erlang server to terminate, it 
                    sets a stop flag to the Java server environment, requesting the 
                    server to terminate.</p>
                </item>
                <item>
                  <p><c>void __reconnect()</c> which closes the current client connection
                    if open and then connects to the same server.</p>
                </item>
              </list>
              <p>The Environment variable is now declared as <c>public</c>. </p>
            </item>
            <item>
              <p>On the Java server skeleton :</p>
              <p></p>
              <list type="bulleted">
                <item>
                  <p><c>boolean __isStopped()</c> which returns true if a <c>stop</c> 
                    message where received, false otherwise. The user must check if 
                    this function returns true, and in this case exit the implemented
                    server loop.</p>
                </item>
              </list>
              <p>The Environment variable is now declared as <c>protected</c> which 
                allows the implementation that extends the stub to access it.</p>
            </item>
            <item>
              <p>On the  Erlang gen_server stub :</p>
              <p></p>
              <list type="bulleted">
                <item>
                  <p><c>stop(Server)</c> which yields to a cast call to the standard 
                    gen_server <c>stop</c> function. This will always terminate the 
                    Erlang gen_server, while it will set the stop flag for the 
                    Java server stub.</p>
                </item>
              </list>
            </item>
          </list>
          <p>Own Id: OTP-3433</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 4.0</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>New types handled by IC.</p>
          <p>The following OMG-IDL types are added in this compiler version :</p>
          <list type="bulleted">
            <item>
              <p>long long</p>
              <p>unsigned long long</p>
              <p>wchar</p>
              <p>wstring</p>
            </item>
          </list>
          <p>Own Id: OTP-3331</p>
          <p></p>
        </item>
        <item>
          <p>TypeCode as built in type and access code files for array and sequence types.</p>
          <list type="bulleted">
            <item>
              <p>As TypeCode is a  <c>pseudo</c>-interface, it is now is a built-in type on IC.</p>
            </item>
            <item>
              <p>Access code files which contain information about TypeCode, ID and Name are 
                now generated for user defined arrays and sequences.</p>
            </item>
          </list>
          <p>Own Id: OTP-3392</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.8.2</title>
    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <p>A bug is fixed on preprocessor directive expansion.</p>
      <p>When nested #ifdef - #ifndef directives, a bug caused
        improper included file expansion. This is fixed by 
        repairing the preprocessor expansion function.</p>
      <p>Own Id: OTP-3472</p>
    </section>
  </section>

  <section>
    <title>IC 3.8.1</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>Build in Erlang types support for java-backends</p>
          <p>The built-in Erlang types <c>term, port, ref</c> and <c>pid</c> 
            are needed in Java backends in order to support an
            efficient mapping between the two languages.
            The new types are also supported by additional 
            helpers and holders to match with OMGs Java mapping
            As a result of this, the following classes are added to 
            the <c>com.ericsson.otp.ic</c> interface :</p>
          <list type="bulleted">
            <item>
              <p><c>Term,TermHelper,TermHolder</c> which represents the 
                built-in Erlang type <c>term</c></p>
            </item>
            <item>
              <p><c>Ref,RefHelper,RefHolder</c> which represents the 
                built-in Erlang type <c>ref</c></p>
            </item>
            <item>
              <p><c>Port,PortHelper, PortHolder</c> which represents the 
                built-in Erlang type <c>port</c></p>
            </item>
            <item><c>Pid, PidHelper and PidHolder</c> which represents the 
             built-in Erlang type <c>pid</c></item>
          </list>
          <p></p>
          <p>Own Id: OTP-3348</p>
          <p></p>
        </item>
        <item>
          <p>Compile time preprocessor macro variable definitions</p>
          <p>The preprocessor lacked possibility to accept user
            defined variables other than the one defined in IDL files.
            This limited the use of command-ruled IDL specifications.
            Now the build-in preprocessor allows the user to set variables
            by using the "preproc_flags" option the same way 
            as using the "gcc" preprocessor.</p>
          <p>Supported flags : </p>
          <list type="bulleted">
            <item>
              <p><c><![CDATA["-D< Variable >"]]></c> which defines a variable</p>
            </item>
            <item>
              <p><c><![CDATA["-U< Variable >"]]></c> which undefines a variable</p>
            </item>
          </list>
          <p></p>
          <p>Own Id: OTP-3349</p>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <p>A bug on comment type expansion is fixed.</p>
      <p>The comment type expansion were errornous when 
        inherited types (NOC backend).
        This is now fixed and the type naming agree with
        the scope of the inheritor interface.</p>
      <p>Own Id: OTP-3346</p>
    </section>
  </section>

  <section>
    <title>IC 3.8</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>The code generated for java backend is optimized 
            due to use of streams instead for tuple classes
            when (un)marshalling message calls.
            Support for building clients using asynchronous 
            client calls and effective multi-threaded servers.</p>
          <p>Own Id: OTP-3310</p>
          <p></p>
        </item>
        <item>
          <p>The <c>any</c> type is now supported for java backend.</p>
          <p>Own Id: OTP-3311</p>
        </item>
      </list>
    </section>

    <section>
      <title>A bug on C generated constants is fixed</title>
      <p>While the constants are evaluated and behave well when used
        inside an IDL specification their C-export were not working properly.
        The constant export definitions were not generated well :</p>
      <list type="bulleted">
        <item>
          <p>the declared C definition were errornous ( the name did not always agree
            with the scope the constant were declared in ).</p>
        </item>
        <item>
          <p>there were no C- definition generated for the c-server backend when 
            the constants were declared inside an interface.</p>
        </item>
      </list>
      <p>Own Id: OTP-3219</p>
    </section>

    <section>
      <title>Incompatibilities</title>
      <p>Due to optimizations in java backend, the stub initialization and usage 
        differs than the previous version.</p>
      <p>Client stub interface changes:</p>
      <list type="bulleted">
        <item>
          <p>Client disconnects by calling the <c>__disconnect()</c> function instead 
            for the old <c>_closeConnection()</c></p>
          <p></p>
        </item>
        <item>
          <p>All <c>marshal</c> operation functions have now the interface :</p>
          <p><c><![CDATA[void _< OpName >_marshal(Environment<, Param |, Params >)]]></c></p>
          <p>instead for</p>
          <p><c><![CDATA[OtpErlangTuple _< OpName >_marshal(< Param, | Params, >OtpErlangPid, OtpErlangRef)]]></c></p>
          <p></p>
        </item>
        <item>
          <p>All <c>unmarshal</c> operation functions have now the interface :</p>
          <p><c><![CDATA[< Ret value > _< OpName >_unmarshal(Environment<, Param |, Params >)]]></c></p>
          <p>instead for</p>
          <p><c><![CDATA[< Ret value > _< OpName >_unmarshal(< Param, | Params, >OtpErlangTuple, OtpErlangRef)]]></c></p>
          <p></p>
        </item>
        <item>
          <p>Call reference extraction is available by the client function :</p>
          <p><c>OtpErlangRef __getRef()</c></p>
          <p>instead for previous function :</p>
          <p><c>OtpErlangRef _getReference(OtpErlangTuple)</c></p>
          <p></p>
        </item>
      </list>
      <p>Server skeleton interface changes:</p>
      <list type="bulleted">
        <item>
          <p>The implementation function no longer have to contain the 
            two (2) contructor functions (with <c>super()</c>). This is due 
            to the fact that there is only one contractor function for each 
            skeleton file :</p>
          <p><c><![CDATA[public _< interface name >ImplBase()]]></c></p>
          <p></p>
        </item>
        <item>
          <p>The parameter for the caller identity extraction function <c>_getCallerPid</c>
            is now an <c>Environment</c> variable instead for an <c>OtpErlangTuple</c>.</p>
          <p></p>
        </item>
        <item>
          <p>There is a new <c>invoke</c> function :</p>
          <p><c>OtpOutputStream invoke(OtpInputStream)</c></p>
          <p>instead for the old one :</p>
          <p><c>OtpErlangTuple invoke(OtpErlangTuple)</c></p>
          <p></p>
        </item>
        <item>
          <p>The <c>OtpConnection</c> class function used for receiving messages is now :</p>
          <p><c>OtpInputStream receiveBuf()</c></p>
          <p>instead for the old one :</p>
          <p><c>OtpErlangTuple receive()</c></p>
          <p></p>
        </item>
        <item>
          <p>The <c>OtpConnection</c> class function used for sending messages is now :</p>
          <p><c>void sendBuf(OtpErlangPid, OtpOutputStream)</c></p>
          <p>instead for the old one :</p>
          <p><c>void send(OtpErlangPid, OtpErlangTuple)</c></p>
          <p></p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.7.1</title>

    <section>
      <title>Improvements and New Features</title>
      <p>Some memory usage optimizations for the compiler were done.</p>
    </section>

    <section>
      <title>Fixed bugs and malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A bug is fixed when C backend is used.</p>
          <p>When C-union with enumerant discriminator, the size 
            calculation of the discriminator value were errornous.
            This lead to the side effect that only the first case of the
            union were allowed.
            The error were fixed by fixing the size calculation of 
            the discriminator. </p>
          <p>Own Id: OTP-3215</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.7</title>
    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A bug is fixed when C backend is used.</p>
          <p>When unions with enumerant discriminator 
            were decoded, an error encountered in the
            union size calculation. </p>
          <p>Own Id: OTP-3209</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.6</title>
    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A bug is fixed when NOC backend is used.</p>
          <p>When several functions with the same name
            were found in the included file tree,
            a compile time failure occurred.</p>
          <p>Own Id: OTP-3203</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.5</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>Noc backend optimization</p>
          <p>When NOC backend is choosen, the type code 
            information on the stub functions is reduced 
            to a single atom "no_tk".
            This is the default behavior. The typecode
            generation is enabled by the "use_tk" switch.</p>
          <p>Own Id: OTP-3196</p>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>General java backend bug fixes </p>
          <p>Protocol errors on user defined structures and 
            union types are corrected.</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.4</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>Semantic test enhancements.</p>
          <p>The compiler detects now semantic errors when enumerant
            values collide with user defined types on the same name scope.</p>
          <p>Own Id: OTP-3157            <br></br>
</p>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>General java backend bug-fixes </p>
          <p>Several bugs were fixed on user defined types.</p>
          <list type="bulleted">
            <item>
              <p>Union discriminators work better when 
                all possible case values are defined.</p>
            </item>
            <item>
              <p>A bug on Interface inherited operations is
                fixed that cause errors on generated server switch.</p>
            </item>
            <item>
              <p>Type definitions on included files are better generated. </p>
            </item>
          </list>
          <p>Own Id: OTP-3156            <br></br>
</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.3</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>A new back-end which generates Java code according to the CORBA IDL to Java mapping for
            communication with the Erlang distribution protocol has been added to IC.
            For the moment there is no support for the Erlang types Pid, Ref, Port and Term 
            but this will be added later.</p>
          <p>Own Id: OTP-2779            <br></br>
</p>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>Fixed the bug that the c code backends sometimes generated incorrect code for
            struct arguments. They shall always be pointers. </p>
          <p>Own Id: OTP-2732            <br></br>
</p>
        </item>
        <item>
          <p>The code generation is fixed so the array parameters now follow the 
            CORBA V2.0 C mapping.</p>
          <p>Own Id: OTP-2873            <br></br>
</p>
        </item>
        <item>
          <p>Fixed the problem that the checking of the numbers of out-parameters always was true.</p>
          <p>Own Id: OTP-2944            <br></br>
</p>
        </item>
        <item>
          <p>Fixed the bug that some temporary variables was not declared when c code.</p>
          <p>Own Id: OTP-2950            <br></br>
</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.2.2</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>Unions are now supported to agree with OMG's C mapping.</p>
          <p>Own Id: OTP-2868            <br></br>
</p>
        </item>
        <item>
          <p>There is now a possibility to use pre- and postcondition methods on the server side
            for IC generated Corba Objects. The compiler option is documented in the ic reference manual
            and an example of how the pre- and postcondition methods should be designed and used is 
            added to ic example directory (an ReadMe.txt file exists with some instructions for 
            running the example code).</p>
          <p>Own Id: OTP-3068            <br></br>
</p>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>The compiler ignores unknown/non supported pragma directives. A warning is raised 
            while the generated code will then be the same as if the corresponding 
            (unkown) pragma directive were missing. </p>
          <p>Own Id: OTP-3052            <br></br>
</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.2.1</title>
    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>Wrong C code was generated for limited strings when they where included
            from another IDL specification.</p>
          <p>Own Id: OTP-3033            <br></br>
</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.2</title>
    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>The buffers for in/output used by C-stubs are now expandable.
            This fixes buffer overflow problems when messages received/sent
            do not fit in buffers.</p>
          <p>Own Id: OTP-3001            <br></br>
</p>
        </item>
      </list>
    </section>

    <section>
      <title>Incompatibilities</title>
      <p>The CORBA_Environment structure has now two new fields, the buffers for in/output
        must now be dynamically allocated.</p>
    </section>
  </section>

  <section>
    <title>IC 3.1.2</title>
    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>The generated IFR registration function for constants has been fixed
            so the parameters are correct.</p>
          <p>Own Id: OTP-2856            <br></br>
</p>
        </item>
        <item>
          <p>Error in the C code generation of ONEWAY operations without parameters
            The bug was an decoding error in the operation header. The generated code expected one
            parameter instead of zero. This is now fixed.</p>
          <p>Own Id: OTP-2909            <br></br>
</p>
        </item>
        <item>
          <p>Type problems on floats and booleans fixed.</p>
          <p>Erroneous code for runtime checks on float was removed and 
            the internal format of the data representing the boolean value 
            is uppgraded.</p>
          <p>Own Id: OTP-2925            <br></br>
</p>
        </item>
        <item>
          <p>The generated code for arrays of typedefined strings were
            erroneous in the C-backends due to a failure in the compiler internal type
            checking.</p>
          <p>Own Id: OTP-2936            <br></br>
</p>
        </item>
        <item>
          <p>The generated code for typedefined nested sequences were erroneous 
            in the C-backends. Pointer mismatches caused compilation failure.</p>
          <p>Own Id: OTP-2937            <br></br>
</p>
        </item>
      </list>
    </section>

    <section>
      <title>Incompatibilities</title>
      <p>The IDL specifications must be regenerated for C due to changes in the code generation.</p>
      <p>One must regenerate IDL specifications for Erlang CORBA if there are constants in the 
        specification due to previous errors in the IFR registration functions (OTP-2856).</p>
    </section>
  </section>

  <section>
    <title>IC 3.1.1</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>Improvements on error report on unsupported types by</p>
          <p>propagating warning when declaring unions in C -backends</p>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A bug is fixed when arrays that contained variable size data
            on C-backends</p>
          <p>The compiler generated errornous code when IDL 
            defined arrays that contained variable size data such
            as strings, variable size structs or sequences.</p>
          <p>Own Id: OTP-2900            <br></br>
</p>
        </item>
        <item>
          <p>A bug is fixed when sequences that contained variable size data
            on C_backends</p>
          <p>The compiler generated errornous code when IDL 
            defined arrays that contained variable size data such
            as strings, variable size structs or other sequences.</p>
          <p>Own Id: OTP-2901            <br></br>
</p>
        </item>
        <item>
          <p>A bug concerning bounded strings on C-backends is fixed.</p>
          <p>The compiler generated errornous code for IDL 
            defined bounded strings. Syntax errors were generated
            in special cases of typdedefined strings.</p>
          <p>Own Id: OTP-2898            <br></br>
</p>
        </item>
        <item>
          <p>A runtime error when sequences that contained integer types is fixed.</p>
          <p>When C-clients/server that communicated with Erlang clients/servers,
            and the data send by Erlang part were a list of small numbers,
            the Erlang runtime compacts the list to a string. This caused a 
            runtime error when sending sequences of integer types and all had 
            value less than 256.</p>
          <p>Own Id: OTP-2899            <br></br>
</p>
        </item>
        <item>
          <p>An OMG IDL - C mapping problem on enumerant values is fixed.</p>
          <p>The enumerant values names is now prefixed by the current scope,
            as defined in the specification.</p>
          <p>Own Id: OTP-2902            <br></br>
</p>
        </item>
        <item>
          <p>A problem when using constants in array declarations is fixed.</p>
          <p>Array dimensions declared with constants generated erroneous code.</p>
          <p>Own Id: OTP-2864            <br></br>
</p>
        </item>
      </list>
    </section>

    <section>
      <title>Incompatibilities</title>
      <list type="bulleted">
        <item>
          <p>Changes in C-generation on enumerant values.</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.1</title>
    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A bug is fixed on the generated structures.  </p>
          <p>The generated C code for the structures corresponds now
            to direct mapping of C-structs.  </p>
          <p>Own Id: OTP-2843            <br></br>
</p>
        </item>
      </list>
    </section>

    <section>
      <title>Incompatibilities</title>
      <list type="bulleted">
        <item>
          <p>Included structures inside a struct are no longer pointers.</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 3.0</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>Interface change for C-backends</p>
          <p>Major interface change. The new interface is CORBA 2.0
            compliant.</p>
          <p>Own Id: OTP-2845            <br></br>
</p>
        </item>
        <item>
          <p>The C-backends functionality is improved</p>
          <list type="bulleted">
            <item>
              <p>Due to interface change and some unneeded error 
                checks,the C-generated code is fairly optimized.</p>
            </item>
          </list>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>Several serious bugs on decoding and memory allocation are fixed. </p>
        </item>
      </list>
    </section>

    <section>
      <title>Incompatibilities</title>
      <list type="bulleted">
        <item>
          <p>Interface change on the C-backends</p>
          <p>In order to be CORBA 2.0 compatible, the new version
            generates fully incompatible C code.</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 2.5.1</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>A new backend is added : C-server</p>
          <p>This back-ends can be used to create servers,
            compatible to c-clients, and Erlang genserver clients.
            The code produced is a collection of functions for
            encoding and decoding messages and a switch that coordinates
            them. These parts can be used to create other servers as well.
            All functions are exported to header files.</p>
          <p>Own Id: OTP-2713            <br></br>
</p>
        </item>
        <item>
          <p>The C-client functionality is improved</p>
          <list type="bulleted">
            <item>
              <p>The static buffer used for input/output is removed along
                with the <c>memset</c> function that initiated it.
                The new client is at least 20-30 percent faster.</p>
            </item>
            <item>
              <p>The internal structure of the client is changed.
                The client functions are now a collection of encoding 
                and decoding message functions ruled by a specific
                call function. While the basic client generated is
                a synchronous client, the exported functions 
                support the implementation of threaded asynchronous
                clients.</p>
            </item>
            <item>
              <p>The static buffer used for input/output is remove along
                with the <c>memset</c> function that initiated it.
                The new client is at least 20-30 percent faster.</p>
            </item>
            <item>
              <p>The code generated is generally improved, warnings are
                (almost) eliminated, while no unidentified variable
                errors occur.</p>
            </item>
            <item>
              <p>The IDL types unsigned shorts, shorts, floats are supported now.</p>
            </item>
            <item>
              <p>All generated functions are exported in client header files..</p>
            </item>
          </list>
          <p>Own Id: OTP-2712            <br></br>
</p>
        </item>
      </list>
    </section>

    <section>
      <title>Changes in compiler usage and code generation.</title>
      <list type="bulleted">
        <item>
          <p>A new option is added for the C-server back-end : <c>c_server</c>.</p>
        </item>
        <item>
          <p>A new option is added : <c>scoped_op_calls</c>.</p>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>A bug oneway operations on erl_corba and erl_genserv that caused 
            en exit due to internal interface error is fixed. </p>
        </item>
        <item>
          <p>A bug on oneway operations on c_genserv back-end that caused several 
            variables to be unidentifined is fixed. </p>
        </item>
      </list>
    </section>

    <section>
      <title>Incompatibilities</title>
      <list type="bulleted">
        <item>
          <p>Interface change on the C-client</p>
          <p>The client functions are called with two extra variables, a pointer to 
            an array of char - used for storage and an integer - the array size</p>
        </item>
        <item>
          <p>The IDL type <c>attribute</c> is disabled, due to some implementation problems.</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 2.1</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>The compiler now provides more in depth information (printouts) when errors occur.</p>
          <p>In some cases the compiler stops compiling 
            due to an abnormal exit or incompatible input.
            In this situation, a "fatal error" may occur but the compiler will 
            generate information explaining the problem.</p>
          <p>Own Id: OTP-2565            <br></br>
</p>
        </item>
      </list>
    </section>
  </section>

  <section>
    <title>IC 2.0</title>

    <section>
      <title>Improvements and New Features</title>
      <list type="bulleted">
        <item>
          <p>The IDL compiler is now a separate application and is longer a part of Orber.</p>
        </item>
        <item>
          <p>Pragma handling implementation.</p>
          <p>Pragma ID, prefix
            and version are implemented to agree  with CORBA revision
            2.0. The compiler accepts and applies these on the
            behavior of the compiled code.            <br></br>
 In this implementation,
            pragmas are accepted by the parser  and applied by the use
            of ic_pragma functions.             <br></br>
 All IFR-identity handling now
            passes through pragma table. As pragma handling in OMG-IDL
            is affecting the identity of an ifr-object, all identity
            handling and registration is now controlled by pragma
            functions. A hash table called "pragmatab" contains vital
            identity information used under compilation.            <br></br>
</p>
          <p>There two major pragma categories :</p>
          <list type="bulleted">
            <item>
              <p>Normal pragmas,  are used in the code where
                basic definitions and statements appear. </p>
            </item>
            <item>
              <p>Under certain circumstances, ugly pragmas can now
                appear  inside  code,  parameter lists, structure
                definitions ... etc.                  <br></br>
 It is quite challenging to
                allow ugly pragmas, but the effects of unlimited ugly
                pragma  implementation on the parser can be enormous.
                Ugly pragmas can cause the parser source code to
                become  time consuming and user unreadable.                  <br></br>
 In order
                to allow ugly pragmas but not destroy  the current
                structure of the parser, the use of ugly pragmas is
                limited.  Multiple pragma directives are allowed
                inside parameter  lists, unions, exceptions,
                enumerated type, structures... as long as they are do not
                appear between two  keywords or between keywords and
                identifiers. </p>
            </item>
          </list>
          <p>The pragma effect is the same for both scope and basic
            pragma rules. </p>
          <p>When compiling, an IFR-identity
            must be looked up several times but by storing identity aliases inside
            the pragma table there this an increase in both speed and
            flexibility. </p>
          <p>Own Id: OTP-2128            <br></br>
</p>
        </item>
        <item>
          <p>Code for interface inheritance registration for the IFR
            registration code .</p>
          <p>Inherited interfaces can now
            be registered as a list of interface descriptions by
            entering code for inherited interface registration under
            new interface creation. This is achieved by correcting the
            function reg2/6 and adding two more functions,
            get_base_interfaces/2 and call_fun_str/2 </p>
          <p>Own Id:
            OTP-2134            <br></br>
</p>
        </item>
        <item>
          <p>IFR registration checks for included IDL files.</p>
          <p>All top level  definitions (with respect to the scope) -
            modules, interfaces, constants, types or exceptions - found 
            in an IDL file are either defined inside the compiled IDL 
            file or inside included files.
            By having an extended registration of all top level
            definitions it becomes possible to simply produce checks 
            for those included by the current IDL file.
            A function call include_reg_test/1 is added in all 
            OE_* files that checks for IFR-registration on all included 
            IDL files. The code for that function is added inside the 
            OE_* file, while the function is called under OE_*:OE_register/0
            operation. </p>
          <p>Own Id: OTP-2138            <br></br>
</p>
        </item>
        <item>
          <p>Exception registration under IFR-operation creation.</p>
          <p>By entering code for exception registration under operation
            creation, the exceptions of an operation can be checked now.
            This is done by correcting the function get_exceptions/4
            and adding two more functions, excdef/5 and get_EXC_ID/5 
            ( the last two are cooperating with the first one and
            all three are defined in the module "ictk" ). </p>
          <p>Own Id: OTP-2102            <br></br>
</p>
        </item>
        <item>
          <p>New back-end to IDL compiler : Plain Erlang.</p>
          <p>The new back-end just translates IDL specifications
            to Erlang module calls. No pragmas are allowed.</p>
          <p>Own Id: OTP-2471            <br></br>
</p>
        </item>
        <item>
          <p>New back-end to IDL compiler : generic server.</p>
          <p>A new back-end that translates IDL specifications
            to a standard OTP generic server.</p>
          <p>Own Id: OTP-2482            <br></br>
</p>
        </item>
        <item>
          <p>New back-end to IDL compiler : c client generation</p>
          <p>A new back-end that translates IDL specifications
            to a C API for accessing servers in Erlang. </p>
          <p>Own Id: OTP-1511            <br></br>
</p>
        </item>
        <item>
          <p>All records in generated files reveal own Erlang modules.</p>
          <p>In Erlang related back-ends, every structure
            which generates definition form is a record,
            (such as union, struct, exception.... ). These records are 
            held in a generated Erlang files which 
            contain functions that reveal record information.            <br></br>

            The Erlang file which contain these functions is 
            named after the scope of the record (similar 
            to the generated module and interface files).            <br></br>

            Three functions are available :</p>
          <list type="bulleted">
            <item>
              <p>tc/0 - returns the record type code,</p>
            </item>
            <item>
              <p>id/0 - returns the record id,</p>
            </item>
            <item>
              <p>name - returns the record name.</p>
            </item>
          </list>
          <p>Own Id: OTP-2473            <br></br>
</p>
        </item>
        <item>
          <p>Changes in compiler usage and code generation.</p>
          <list type="bulleted">
            <item>
              <p>New compilation flags.
                New flag be ( = back-end ) which is
                used by the compiler to choose back-end. 
                Default back-end is set to erl_corba.</p>
            </item>
            <item>
              <p>Stub files have an extra function oe_dependency/0
                indicating file dependency. This
                helps the user to determine which IDL  files should to
                be compiled beside the compiled file.  </p>
            </item>
          </list>
          <p>Own Id: OTP-2474            <br></br>
</p>
        </item>
        <item>
          <p>The IDL generation for CORBA is changed so standard gen_server return values can be used
            from the implementation module. The change is compatible so that old values remain valid.</p>
          <p>Own Id: OTP-2485            <br></br>
</p>
        </item>
        <item>
          <p>It's now possible to generate an API to a CORBA object that accepts 
            timeout values in the calls in the same manner as gen_server.
            The option to the compiler is "timeout".</p>
          <p>Own Id: OTP-2487            <br></br>
</p>
        </item>
      </list>
    </section>

    <section>
      <title>Fixed Bugs and Malfunctions</title>
      <list type="bulleted">
        <item>
          <p>Empty file generation problem is fixed.
            When the IDL module definition did not contain 
            constant definitions, the generated stub file for that module 
            definition was empty. After checking the module body, 
            these files will not be generated anymore.</p>
        </item>
      </list>
    </section>

    <section>
      <title>Incompatibilities</title>
      <list type="bulleted">
        <item>
          <p>Changes in generated files.</p>
          <p>Stub-files generated by the compiler had
            prefix "OE_" and those used by Orber
            had also a register/unregister function
            called "OE_register"/"OE_unregister" and
            a directive "OE_get_interface" passed 
            to the gen_server.
            This made it difficult/irritating to use,
            for example call to the register function
            in Orber would appear as shown below:</p>
          <list type="bulleted">
            <item>
              <p>'OE_filename':'OE_register'().</p>
            </item>
          </list>
          <p>This is changed by using the prefix "oe_"
            instead for "OE_" for the above.
            A registration call in Orber is now written:</p>
          <list type="bulleted">
            <item>
              <p>oe_filename:oe_register(). </p>
            </item>
          </list>
          <p>Own Id: OTP-2440            <br></br>
</p>
        </item>
      </list>
    </section>
  </section>
</chapter>

